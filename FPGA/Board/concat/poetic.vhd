-- VHDL Entity Board.poetic_circuit.symbol
--
-- Created:
--          by - jean.nanchen.UNKNOWN (WEA30407)
--          at - 16:53:31 22.07.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY poetic_circuit IS
    GENERIC( 
        bitNb : positive := 16
    );
    PORT( 
        ADC_SDO  : IN     std_ulogic;
        D        : IN     std_uLogic;
        USB_TX   : IN     std_ulogic;
        clock    : IN     std_ulogic;
        reset_N  : IN     std_ulogic;
        ADC_CS   : OUT    std_ulogic;
        ADC_SCLK : OUT    std_ulogic;
        BP_PWMA  : OUT    std_ulogic;
        BP_PWMB  : OUT    std_ulogic;
        DAC_SCLK : OUT    std_ulogic;
        DAC_SDO  : OUT    std_ulogic;
        DAC_SYNC : OUT    std_ulogic;
        Q        : OUT    std_uLogic;
        Q1       : OUT    std_uLogic;
        USB_RX   : OUT    std_ulogic
    );

-- Declarations

END poetic_circuit ;





-- VHDL Entity Poetic.SimplePoeticDcMotor.symbol
--
-- Created:
--          by - jean.nanchen.UNKNOWN (WEA30407)
--          at - 16:16:43 22.07.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY SimplePoeticDcMotor IS
    GENERIC( 
        dataBitNb  : positive := 8;
        pidBitNb   : positive := 12;
        adcBitNb   : positive := 12;
        dacBitNb   : positive := 8;
        dacChBitNb : positive := 2;
        dacOpBitNb : positive := 2
    );
    PORT( 
        ADC_SDO  : IN     std_ulogic;
        D        : IN     std_ulogic;
        I        : IN     std_ulogic;
        P        : IN     std_ulogic;
        USB_TX   : IN     std_ulogic;
        clock    : IN     std_ulogic;
        enable   : IN     std_ulogic;
        reset    : IN     std_ulogic;
        ADC_CS   : OUT    std_ulogic;
        ADC_SCLK : OUT    std_ulogic;
        BP_PWMA  : OUT    std_ulogic;
        BP_PWMB  : OUT    std_ulogic;
        DAC_SCLK : OUT    std_ulogic;
        DAC_SDO  : OUT    std_ulogic;
        DAC_SYNC : OUT    std_ulogic;
        USB_RX   : OUT    std_ulogic
    );

-- Declarations

END SimplePoeticDcMotor ;





-- VHDL Entity RS232.serialPortFIFO.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:45:49 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY serialPortFIFO IS
    GENERIC( 
        baudRateDivide : positive := 2083;
        dataBitNb      : positive := 8;
        txFifoDepth    : positive := 8;
        rxFifoDepth    : positive := 8
    );
    PORT( 
        RxD     : IN     std_ulogic;
        TxD     : OUT    std_ulogic;
        clock   : IN     std_ulogic;
        reset   : IN     std_ulogic;
        rxEmpty : OUT    std_ulogic;
        rxRd    : IN     std_ulogic;
        rxData  : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        txData  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        txFull  : OUT    std_ulogic;
        txWr    : IN     std_ulogic
    );

-- Declarations

END serialPortFIFO ;





-- VHDL Entity RS232.serialPortReceiver.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:45:48 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY serialPortReceiver IS
    GENERIC( 
        dataBitNb      : positive := 8;
        baudRateDivide : positive := 2083
    );
    PORT( 
        RxD       : IN     std_ulogic;
        clock     : IN     std_ulogic;
        reset     : IN     std_ulogic;
        dataOut   : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataValid : OUT    std_ulogic
    );

-- Declarations

END serialPortReceiver ;





--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Common Lib
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
--     added documentation
-- -----------------------------------------------------------------------------
library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;

PACKAGE CommonLib IS

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to represent the given val
  -- Examples:
  --   requiredBitNb(1) = 1   (1)
  --   requiredBitNb(2) = 2   (10)
  --   requiredBitNb(3) = 2   (11)
  function requiredBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to count val times (0 to val-1)
  -- Examples:
  --   counterBitNb(1) = 1    (0)
  --   counterBitNb(2) = 1    (0->1)
  --   counterBitNb(3) = 2    (0->1->10)
  function counterBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Functions to return one or the other input based on a boolean.
  -- Can be used to build conditional constants.
  -- Example:
  --   constant bonjour_c : string := sel(ptpRole = master, "fpga20", "fpga02");
  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer;
  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string;
  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector;
  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned;
  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed;

END CommonLib;




--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Often used functions
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
-- -----------------------------------------------------------------------------
PACKAGE BODY CommonLib IS

  function requiredBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo <= val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end requiredBitNb;

  function counterBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo < val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end counterBitNb;

  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

END CommonLib;




-- library Common;
  use work.CommonLib.all;

architecture RTL of serialPortReceiver is

  signal dividerCounter: unsigned(requiredBitNb(baudRateDivide-1)-1 downto 0);
  signal dividerCounterReset: std_uLogic;
  signal rxDelayed: std_uLogic;
  signal dividerCounterSynchronize: std_uLogic;
  signal rxSample: std_uLogic;
  signal rxShiftReg: std_ulogic_vector(dataBitNb-1 downto 0);
  signal rxReceiving: std_uLogic;
  signal rxDataValid: std_uLogic;
  signal rxCounter: unsigned(requiredBitNb(dataBitNb)-1 downto 0);

begin

  divide: process(reset, clock)
  begin
    if reset = '1' then
      dividerCounter <= (others => '0');
    elsif rising_edge(clock) then
      if dividerCounterSynchronize = '1' then
        dividerCounter <= to_unsigned(baudRateDivide/2, dividerCounter'length);
      elsif dividerCounterReset = '1' then
        dividerCounter <= (others => '0');
      else
        dividerCounter <= dividerCounter + 1;
      end if;
    end if;
  end process divide;

  endOfCount: process(dividerCounter)
  begin
    if dividerCounter = baudRateDivide-1 then
      dividerCounterReset <= '1';
    else
      dividerCounterReset <= '0';
    end if;
  end process endOfCount;

  delayRx: process(reset, clock)
  begin
    if reset = '1' then
      rxDelayed <= '0';
    elsif rising_edge(clock) then
      rxDelayed <= RxD;
    end if;
  end process delayRx;

  rxSynchronize: process(RxD, rxDelayed)
  begin
    if RxD /= rxDelayed then
      dividerCounterSynchronize <= '1';
    else
      dividerCounterSynchronize <= '0';
    end if;
  end process rxSynchronize;

  rxSample <= dividerCounterReset;

  shiftReg: process(reset, clock)
  begin
    if reset = '1' then
      rxShiftReg <= (others => '0');
    elsif rising_edge(clock) then
      if rxSample = '1' then
        rxShiftReg(rxShiftReg'high-1 downto 0) <= rxShiftReg(rxShiftReg'high downto 1);
        rxShiftReg(rxShiftReg'high) <= RxD;
      end if;
    end if;
  end process shiftReg;

  detectReceive: process(reset, clock)
  begin
    if reset = '1' then
      rxReceiving <= '0';
      rxDataValid <= '0';
    elsif rising_edge(clock) then
      if rxSample = '1' then
        if rxCounter = dataBitNb-1 then
          rxDataValid <= '1';
        elsif RxD = '0' then
          rxReceiving <= '1';
        end if;
      elsif rxDataValid = '1' then
        rxReceiving <= '0';
        rxDataValid <= '0';
      end if;
    end if;
  end process detectReceive;

  countRxBitNb: process(reset, clock)
  begin
    if reset = '1' then
      rxCounter <= (others => '0');
    elsif rising_edge(clock) then
      if rxSample = '1' then
        if rxReceiving = '1' then
          rxCounter <= rxCounter + 1;
        else
          rxCounter <= (others => '0');
        end if;
      end if;
    end if;
  end process countRxBitNb;

  dataOut <= rxShiftReg;
  dataValid <= rxDataValid;

end RTL;





-- VHDL Entity Memory.FIFO.symbol
--
-- Created:
--          by - jeann.UNKNOWN (DESKTOP-V46KISN)
--          at - 09:22:34 17.06.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY FIFO IS
    GENERIC( 
        dataBitNb : positive := 8;
        depth     : positive := 16
    );
    PORT( 
        write   : IN     std_ulogic;
        clock   : IN     std_ulogic;
        reset   : IN     std_ulogic;
        dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        read    : IN     std_ulogic;
        dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        empty   : OUT    std_ulogic;
        full    : OUT    std_ulogic
    );

-- Declarations

END FIFO ;





-- VHDL Entity Memory.FIFO_oneRegister.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:45:15 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY FIFO_oneRegister IS
    GENERIC( 
        dataBitNb : positive := 8
    );
    PORT( 
        write   : IN     std_ulogic;
        clock   : IN     std_ulogic;
        reset   : IN     std_ulogic;
        dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        read    : IN     std_ulogic;
        dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        empty   : OUT    std_ulogic;
        full    : OUT    std_ulogic
    );

-- Declarations

END FIFO_oneRegister ;





architecture oneRegister of FIFO_oneRegister is

  signal dataRegister: std_ulogic_vector(dataIn'range);

begin

  writeReg: process(reset, clock)
  begin
    if reset = '1' then
      dataRegister <= (others => '0');
    elsif rising_edge(clock) then
      if write = '1' then
        dataRegister <= dataIn;
      end if;
    end if;
  end process writeReg;

  dataOut <= dataRegister;

  manageFlags: process(reset, clock)
  begin
    if reset = '1' then
      empty <= '1';
      full  <= '0';
    elsif rising_edge(clock) then
      if write = '1' then
        empty <= '0';
        full  <= '1';
      elsif read = '1' then
        empty <= '1';
        full  <= '0';
      end if;
    end if;
  end process manageFlags;

end oneRegister;





-- VHDL Entity Memory.FIFO_bram.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:45:15 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY FIFO_bram IS
    GENERIC( 
        dataBitNb : positive := 8;
        depth     : positive := 8
    );
    PORT( 
        write   : IN     std_ulogic;
        clock   : IN     std_ulogic;
        reset   : IN     std_ulogic;
        dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        read    : IN     std_ulogic;
        dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        empty   : OUT    std_ulogic;
        full    : OUT    std_ulogic
    );

-- Declarations

END FIFO_bram ;





-- library Common;
  use work.CommonLib.all;

architecture RTL of FIFO_bram is

  subtype register_type is std_ulogic_vector(dataIn'high downto 0);
  type memory_type is array (0 to depth-1) of register_type;

  signal writeCounter: unsigned(requiredBitNb(depth-1)-1 downto 0);
  signal readCounter: unsigned(writeCounter'range);
  signal memoryArray: memory_type;

  type fifoStateType is (
    sEmpty, sFull,
    sRead, sWrite, sWriteFirst,
    sReadWrite, sWait
  );
  signal fifoState: fifoStateType;
  signal emptyCondition, fullCondition, empty_int: std_ulogic;

begin
  ------------------------------------------------------------------------------
                                                      -- read and write counters
  updateWriteCounter: process(reset, clock)
  begin
    if reset = '1' then
      writeCounter <= (others => '0');
    elsif rising_edge(clock) then
      if (write = '1') and  (fullCondition = '0') then
        writeCounter <= writeCounter + 1;
      end if;
    end if;
  end process updateWriteCounter;

  updateReadCounter: process(reset, clock)
  begin
    if reset = '1' then
      readCounter <= (others => '0');
    elsif rising_edge(clock) then
      if (read = '1') and  (empty_int = '0') then
        readCounter <= readCounter + 1;
      end if;
    end if;
  end process updateReadCounter;

  ------------------------------------------------------------------------------
                                                                -- memory access
  writeMem: process(clock)
  begin
    if rising_edge(clock) then
      if (write = '1') and (fullCondition = '0') then
        memoryArray(to_integer(writeCounter)) <= dataIn;
      end if;
    end if;
  end process writeMem;

  readMem: process(reset, clock)
  begin
    if reset = '1' then
      dataOut <= (others => '0');
    elsif rising_edge(clock) then
      if (read = '0') or (empty_int = '1') then
        dataOut <= memoryArray(to_integer(readCounter));
      else
        dataOut <= memoryArray(to_integer(readCounter+1));
      end if;
    end if;
  end process readMem;

  ------------------------------------------------------------------------------
                                                                     -- controls
  emptyCondition <= '1' when
      ( (fifoState = sRead) and (writeCounter = readCounter) ) or
        (fifoState = sEmpty)
    else '0';

  fullCondition <= '1' when
      ( (fifoState = sWrite) and (writeCounter = readCounter) ) or
        (fifoState = sFull)
    else '0';


  fifoControl: process(reset, clock)
  begin
    if reset = '1' then
      fifoState <= sEmpty;
    elsif rising_edge(clock) then
      case fifoState is
        when sEmpty =>
          if write = '1' then
            fifoState <= sWriteFirst;
          end if;
        when sFull =>
          if (read = '1') then
            fifoState <= sRead;
          end if;
        when sRead =>
          if (read = '1') and (write = '1') then
            fifoState <= sReadWrite;
          elsif write = '1' then
            fifoState <= sWrite;
		      elsif emptyCondition = '1' then
            fifoState <= sEmpty;
          elsif read = '1' then
            fifoState <= sRead;
          else
            fifoState <= sWait;
          end if;
        when sWriteFirst =>
          if (read = '1') and (write = '1') then
            fifoState <= sReadWrite;
          elsif write = '1' then
            fifoState <= sWrite;
          elsif read = '1' then
            fifoState <= sRead;
          else
            fifoState <= sWait;
          end if;
        when sWrite =>
          if (read = '1') and (write = '1') then
            fifoState <= sReadWrite;
          elsif read = '1' then
            fifoState <= sRead;
		      elsif fullCondition = '1' then
            fifoState <= sFull;
          elsif write = '1' then
            fifoState <= sWrite;
          else
            fifoState <= sWait;
          end if;
        when sReadWrite =>
          if (read = '0') and (write = '0') then
            fifoState <= sWait;
          elsif (read = '1') and (write = '0') then
            fifoState <= sRead;
          elsif (write = '1') and (read = '0') then
            fifoState <= sWrite;
          end if;
        when sWait =>
          if (read = '1') and (write = '1') then
            fifoState <= sReadWrite;
          elsif read = '1' then
            fifoState <= sRead;
          elsif write = '1' then
            fifoState <= sWrite;
          end if;
        when others => null;
      end case;
    end if;
  end process fifoControl;
  

  full <= '1' when 
        (fifoState = sFull) or
        (fullCondition = '1')
    else '0';

  empty_int <= '1' when
        (fifoState = sEmpty) or
        (fifoState = sWriteFirst) or
        ( (emptyCondition = '1') and (fifoState = sRead) )
    else '0';
  empty <= empty_int;
  
end RTL;




--
-- VHDL Architecture Memory.FIFO.struct
--
-- Created:
--          by - jeann.UNKNOWN (DESKTOP-V46KISN)
--          at - 09:22:34 17.06.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

-- LIBRARY Memory;

ARCHITECTURE struct OF FIFO IS

    -- Architecture declarations

    -- Internal signal declarations


    -- Component Declarations
    COMPONENT FIFO_bram
    GENERIC (
        dataBitNb : positive := 8;
        depth     : positive := 8
    );
    PORT (
        write   : IN     std_ulogic ;
        clock   : IN     std_ulogic ;
        reset   : IN     std_ulogic ;
        dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        read    : IN     std_ulogic ;
        dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        empty   : OUT    std_ulogic ;
        full    : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT FIFO_oneRegister
    GENERIC (
        dataBitNb : positive := 8
    );
    PORT (
        write   : IN     std_ulogic ;
        clock   : IN     std_ulogic ;
        reset   : IN     std_ulogic ;
        dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        read    : IN     std_ulogic ;
        dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        empty   : OUT    std_ulogic ;
        full    : OUT    std_ulogic 
    );
    END COMPONENT;


BEGIN

    -- Instance port mappings.

    g0: IF depth <= 1 GENERATE
    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : FIFO_oneRegister USE ENTITY Memory.FIFO_oneRegister;
    -- pragma synthesis_on

    BEGIN
        I1 : FIFO_oneRegister
            GENERIC MAP (
                dataBitNb => dataBitNb
            )
            PORT MAP (
                write   => write,
                clock   => clock,
                reset   => reset,
                dataOut => dataOut,
                read    => read,
                dataIn  => dataIn,
                empty   => empty,
                full    => full
            );
    END GENERATE g0;

    g1: IF depth > 1 GENERATE
    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : FIFO_bram USE ENTITY Memory.FIFO_bram;
    -- pragma synthesis_on

    BEGIN
        I0 : FIFO_bram
            GENERIC MAP (
                dataBitNb => dataBitNb,
                depth     => depth
            )
            PORT MAP (
                write   => write,
                clock   => clock,
                reset   => reset,
                dataOut => dataOut,
                read    => read,
                dataIn  => dataIn,
                empty   => empty,
                full    => full
            );
    END GENERATE g1;

END struct;




-- VHDL Entity RS232.serialPortTransmitter.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:45:48 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY serialPortTransmitter IS
    GENERIC( 
        dataBitNb      : positive := 8;
        baudRateDivide : positive := 2083
    );
    PORT( 
        TxD    : OUT    std_ulogic;
        clock  : IN     std_ulogic;
        reset  : IN     std_ulogic;
        dataIn : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        send   : IN     std_ulogic;
        busy   : OUT    std_ulogic
    );

-- Declarations

END serialPortTransmitter ;





-- library Common;
  use work.CommonLib.all;

architecture RTL of serialPortTransmitter is

  signal dividerCounter: unsigned(requiredBitNb(baudRateDivide)-1 downto 0);
  signal dividerCounterReset: std_uLogic;
  signal txData: std_ulogic_vector(dataBitNb-1 downto 0);
  signal send1: std_uLogic;
  signal txShiftEnable: std_uLogic;
  signal txShiftReg: std_ulogic_vector(dataBitNb+1 downto 0);
  signal txSendingByte: std_uLogic;
  signal txSendingByteAndStop: std_uLogic;

begin

  divide: process(reset, clock)
  begin
    if reset = '1' then
      dividerCounter <= (others => '0');
    elsif rising_edge(clock) then
      if dividerCounterReset = '1' then
        dividerCounter <= to_unsigned(1, dividerCounter'length);
      else
        dividerCounter <= dividerCounter + 1;
      end if;
    end if;
  end process divide;

  endOfCount: process(dividerCounter, send1)
  begin
    if dividerCounter = baudRateDivide then
      dividerCounterReset <= '1';
    elsif send1 = '1' then
      dividerCounterReset <= '1';
    else
      dividerCounterReset <= '0';
    end if;
  end process endOfCount;

  txShiftEnable <= dividerCounterReset;

  storeData: process(reset, clock)
  begin
    if reset = '1' then
      txData <= (others => '1');
    elsif rising_edge(clock) then
      if send = '1' then
        txData <= dataIn;
      end if;
    end if;
  end process storeData;

  delaySend: process(reset, clock)
  begin
    if reset = '1' then
      send1 <= '0';
    elsif rising_edge(clock) then
      send1 <= send;
    end if;
  end process delaySend;

  shiftReg: process(reset, clock)
  begin
    if reset = '1' then
      txShiftReg <= (others => '1');
    elsif rising_edge(clock) then
      if txShiftEnable = '1' then
        if send1 = '1' then
          txShiftReg <= '0' & txData & '0';
        else
          txShiftReg(txShiftReg'high-1 downto 0) <= txShiftReg(txShiftReg'high downto 1);
          txShiftReg(txShiftReg'high) <= '1';
        end if;
      end if;
    end if;
  end process shiftReg;

  txSendingByte <= '1' when (txShiftReg(txShiftReg'high downto 1) /= (txShiftReg'high downto 1 => '1'))
    else '0';

  txSendingByteAndStop <= '1' when txShiftReg /= (txShiftReg'high downto 0 => '1')
    else '0';

  TxD <= txShiftReg(0) when txSendingByte = '1' else '1';
  busy <= txSendingByteAndStop  or send1 or send;

end RTL;





--
-- VHDL Architecture RS232.serialPortFIFO.struct
--
-- Created:
--          by - jeann.UNKNOWN (DESKTOP-V46KISN)
--          at - 09:23:20 17.06.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.ALL;

-- LIBRARY Memory;
-- LIBRARY RS232;

ARCHITECTURE struct OF serialPortFIFO IS

    -- Architecture declarations

    -- Internal signal declarations
    SIGNAL txSend      : std_ulogic;
    SIGNAL rxWord      : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
    SIGNAL rxWordValid : std_ulogic;
    SIGNAL txFifoEmpty : std_ulogic;
    SIGNAL txWord      : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
    SIGNAL txBusy      : std_ulogic;


    -- Component Declarations
    COMPONENT FIFO
    GENERIC (
        dataBitNb : positive := 8;
        depth     : positive := 16
    );
    PORT (
        write   : IN     std_ulogic ;
        clock   : IN     std_ulogic ;
        reset   : IN     std_ulogic ;
        dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        read    : IN     std_ulogic ;
        dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        empty   : OUT    std_ulogic ;
        full    : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT serialPortReceiver
    GENERIC (
        dataBitNb      : positive := 8;
        baudRateDivide : positive := 2083
    );
    PORT (
        RxD       : IN     std_ulogic ;
        clock     : IN     std_ulogic ;
        reset     : IN     std_ulogic ;
        dataOut   : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataValid : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT serialPortTransmitter
    GENERIC (
        dataBitNb      : positive := 8;
        baudRateDivide : positive := 2083
    );
    PORT (
        TxD    : OUT    std_ulogic ;
        clock  : IN     std_ulogic ;
        reset  : IN     std_ulogic ;
        dataIn : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        send   : IN     std_ulogic ;
        busy   : OUT    std_ulogic 
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : FIFO USE ENTITY Memory.FIFO;
--     FOR ALL : serialPortReceiver USE ENTITY RS232.serialPortReceiver;
--     FOR ALL : serialPortTransmitter USE ENTITY RS232.serialPortTransmitter;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 1 eb1
    process(reset, clock)
      begin
        if reset = '1' then
          txSend <= '0';
        elsif rising_edge(clock) then
          if ( (txFifoEmpty = '0') and (txBusy = '0') ) then
            txSend <= '1';
          else
            txSend <= '0';
          end if;
        end if;
      end process;
          


    -- Instance port mappings.
    I_rxFifo : FIFO
        GENERIC MAP (
            dataBitNb => dataBitNb,
            depth     => rxFifoDepth
        )
        PORT MAP (
            write   => rxWordValid,
            clock   => clock,
            reset   => reset,
            dataOut => rxData,
            read    => rxRd,
            dataIn  => rxWord,
            empty   => rxEmpty,
            full    => OPEN
        );
    I_txFifo : FIFO
        GENERIC MAP (
            dataBitNb => dataBitNb,
            depth     => txFifoDepth
        )
        PORT MAP (
            write   => txWr,
            clock   => clock,
            reset   => reset,
            dataOut => txWord,
            read    => txSend,
            dataIn  => txData,
            empty   => txFifoEmpty,
            full    => txFull
        );
    I_rx : serialPortReceiver
        GENERIC MAP (
            dataBitNb      => dataBitNb,
            baudRateDivide => baudRateDivide
        )
        PORT MAP (
            RxD       => RxD,
            clock     => clock,
            reset     => reset,
            dataOut   => rxWord,
            dataValid => rxWordValid
        );
    I_tx : serialPortTransmitter
        GENERIC MAP (
            dataBitNb      => dataBitNb,
            baudRateDivide => baudRateDivide
        )
        PORT MAP (
            TxD    => TxD,
            clock  => clock,
            reset  => reset,
            dataIn => txWord,
            send   => txSend,
            busy   => txBusy
        );

END struct;




-- VHDL Entity Poetic.uartController.symbol
--
-- Created:
--          by - jean.nanchen.UNKNOWN (WEA30407)
--          at - 16:12:08 08.07.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY uartController IS
    GENERIC( 
        dataBitNb : positive := 8
    );
    PORT( 
        clock        : IN     std_ulogic;
        reset        : IN     std_ulogic;
        rxData       : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        rxEmpty      : IN     std_ulogic;
        txFull       : IN     std_ulogic;
        consigne     : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        endOfMsg     : OUT    std_ulogic;
        newCharacter : OUT    std_ulogic;
        rxRd         : OUT    std_ulogic;
        txData       : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        txWr         : OUT    std_ulogic
    );

-- Declarations

END uartController ;





--
-- VHDL Architecture Poetic.uartController.fsm
--
-- Created:
--          by - jean.nanchen.UNKNOWN (WEA30407)
--          at - 11:59:13 15.07.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
 
ARCHITECTURE fsm OF uartController IS

    TYPE STATE_TYPE IS (
        waitForCommand,
        dispatcher,
        S_select,
        S_receive,
        S_waitForOtherCharacter
    );
 
    -- Declare current and next state signals
    SIGNAL current_state : STATE_TYPE;
    SIGNAL next_state : STATE_TYPE;

    -- Declare any pre-registered internal signals
    SIGNAL consigne_cld : std_ulogic_vector (dataBitNb-1 DOWNTO 0);
    SIGNAL endOfMsg_cld : std_ulogic ;
    SIGNAL newCharacter_cld : std_ulogic ;
    SIGNAL rxRd_cld : std_ulogic ;
    SIGNAL txData_cld : std_ulogic_vector (dataBitNb-1 DOWNTO 0);
    SIGNAL txWr_cld : std_ulogic ;

BEGIN

    -----------------------------------------------------------------
    clocked_proc : PROCESS ( 
        clock,
        reset
    )
    -----------------------------------------------------------------
    BEGIN
        IF (reset = '1') THEN
            current_state <= waitForCommand;
            -- Default Reset Values
            consigne_cld <= (others => '0');
            endOfMsg_cld <= '0';
            newCharacter_cld <= '0';
            rxRd_cld <= '0';
            txData_cld <= (others => '0');
            txWr_cld <= '0';
        ELSIF (clock'EVENT AND clock = '1') THEN
            current_state <= next_state;

            -- Combined Actions
            CASE current_state IS
                WHEN waitForCommand => 
                    newCharacter_cld <= '0';
                    rxRd_cld <= '0';
                    consigne_cld <= (others => '0');
                    endOfMsg_cld <= '0';
                    txData_cld <= (others => '0');
                    txWr_cld <= '0';
                WHEN dispatcher => 
                    IF (rxData = X"53") THEN 
                        rxRd_cld <= '1';
                    ELSE
                        rxRd_cld <= '1';
                    END IF;
                WHEN S_select => 
                    rxRd_cld <= '1';
                    newCharacter_cld <= '0';
                    IF (rxEmpty = '0') THEN 
                        rxRd_cld <= '1';
                    END IF;
                WHEN S_receive => 
                    consigne_cld <= rxData;
                    if rxData /= X"65" then
                      newCharacter_cld <= '1';
                    end if;
                    IF (rxData /= X"65") THEN 
                    ELSIF (rxData = X"65") THEN 
                        endOfMsg_cld <= '1';
                    END IF;
                WHEN S_waitForOtherCharacter => 
                    rxRd_cld <= '0';
                    newCharacter_cld <= '0';
                    IF (rxEmpty = '0') THEN 
                        rxRd_cld <= '1';
                    END IF;
                WHEN OTHERS =>
                    NULL;
            END CASE;
        END IF;
    END PROCESS clocked_proc;
 
    -----------------------------------------------------------------
    nextstate_proc : PROCESS ( 
        current_state,
        rxData,
        rxEmpty
    )
    -----------------------------------------------------------------
    BEGIN
        CASE current_state IS
            WHEN waitForCommand => 
                IF (rxEmpty = '0') THEN 
                    next_state <= dispatcher;
                ELSE
                    next_state <= waitForCommand;
                END IF;
            WHEN dispatcher => 
                IF (rxData = X"53") THEN 
                    next_state <= S_select;
                ELSE
                    next_state <= waitForCommand;
                END IF;
            WHEN S_select => 
                IF (rxEmpty = '0') THEN 
                    next_state <= S_receive;
                ELSE
                    next_state <= S_select;
                END IF;
            WHEN S_receive => 
                IF (rxData /= X"65") THEN 
                    next_state <= S_waitForOtherCharacter;
                ELSIF (rxData = X"65") THEN 
                    next_state <= waitForCommand;
                ELSE
                    next_state <= S_receive;
                END IF;
            WHEN S_waitForOtherCharacter => 
                IF (rxEmpty = '0') THEN 
                    next_state <= S_receive;
                ELSE
                    next_state <= S_waitForOtherCharacter;
                END IF;
            WHEN OTHERS =>
                next_state <= waitForCommand;
        END CASE;
    END PROCESS nextstate_proc;
 
    -- Concurrent Statements
    -- Clocked output assignments
    consigne <= consigne_cld;
    endOfMsg <= endOfMsg_cld;
    newCharacter <= newCharacter_cld;
    rxRd <= rxRd_cld;
    txData <= txData_cld;
    txWr <= txWr_cld;
END fsm;




-- VHDL Entity Poetic.serialAsciiDecoder.symbol
--
-- Created:
--          by - jeann.UNKNOWN (DESKTOP-V46KISN)
--          at - 16:04:54 29.06.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY serialAsciiDecoder IS
    PORT( 
        clock        : IN     std_ulogic;
        consigne     : IN     std_ulogic_vector (7 DOWNTO 0);
        endOfMsg     : IN     std_ulogic;
        newCharacter : IN     std_ulogic;
        reset        : IN     std_ulogic;
        output       : OUT    std_ulogic_vector (11 DOWNTO 0)
    );

-- Declarations

END serialAsciiDecoder ;





--
-- VHDL Architecture Poetic.serialAsciiDecoder.serialAsciiDecoder
--
-- Created:
--          by - jeann.UNKNOWN (DESKTOP-V46KISN)
--          at - 10:55:13 29.06.2021
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE serialAsciiDecoder OF serialAsciiDecoder IS
  type decodeState is (
    isReceiving, endOfReceive, ready, print, increment, incrementAdder
  );
  signal mainState : decodeState;
  type t_Memory is array (0 to 11) of std_ulogic_vector(7 downto 0);
  signal r_Mem : t_Memory;
BEGIN
  decode : process(reset, clock)
    variable counterCharacter : integer;
    variable counterAdder : integer;
	variable uOutput : integer;
  begin
    if reset = '1' then
      uOutput := 0;
      output <= (others => '0');
      mainState <= ready;
      counterCharacter := 0;
      counterAdder := 0;
      for i in 0 to 11 loop
        r_Mem(i) <= (others => '0');
      end loop;
    elsif rising_edge(clock) then
      case mainState is 
        when ready =>
		  uOutput := 0;
          if newCharacter = '1' then
            mainState <= isReceiving;
          end if;
        when isReceiving =>
          if endOfMsg = '1' then
            mainState <= endOfReceive;
          end if;
          if newCharacter = '1' then
            mainState <= increment;
            r_Mem(counterCharacter) <= consigne;
          end if;
        when increment =>
          counterCharacter := counterCharacter + 1;
          mainState <= isReceiving;
        when endOfReceive =>
          if counterAdder = counterCharacter then
            mainState <= print;
          else
            r_Mem(counterAdder) <= (others => '0');
            mainState <= incrementAdder;
			if counterAdder /= counterCharacter - 1 then
				case r_Mem(counterAdder) is
				  when X"30" => uOutput := uOutput * 10;
				  when X"31" => uOutput := (uOutput + 1) * 10;
				  when X"32" => uOutput := (uOutput + 2) * 10;
				  when X"33" => uOutput := (uOutput + 3) * 10;
				  when X"34" => uOutput := (uOutput + 4) * 10;
				  when X"35" => uOutput := (uOutput + 5) * 10;
				  when X"36" => uOutput := (uOutput + 6) * 10;
				  when X"37" => uOutput := (uOutput + 7) * 10;
				  when X"38" => uOutput := (uOutput + 8) * 10;
				  when X"39" => uOutput := (uOutput + 9) * 10;
				  when others =>
				end case;
			else
				case r_Mem(counterAdder) is
				  when X"30" => uOutput := uOutput;
				  when X"31" => uOutput := (uOutput + 1);
				  when X"32" => uOutput := (uOutput + 2);
				  when X"33" => uOutput := (uOutput + 3);
				  when X"34" => uOutput := (uOutput + 4);
				  when X"35" => uOutput := (uOutput + 5);
				  when X"36" => uOutput := (uOutput + 6);
				  when X"37" => uOutput := (uOutput + 7);
				  when X"38" => uOutput := (uOutput + 8);
				  when X"39" => uOutput := (uOutput + 9);
				  when others =>
				end case;
			end if;
          end if;
        when incrementAdder =>
          counterAdder := counterAdder + 1;
          mainState <= endOfReceive;
        when print =>
          output <= std_ulogic_vector(to_unsigned(uOutput, output'length));
          counterCharacter := 0;
          counterAdder := 0;
          mainState <= ready;
      end case;
    end if;
  end process decode;
END ARCHITECTURE serialAsciiDecoder;





-- VHDL Entity Poetic.motorController.symbol
--
-- Created:
--          by - jeann.UNKNOWN (DESKTOP-V46KISN)
--          at - 15:48:33 13.07.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY motorController IS
    GENERIC( 
        pidBitNb : positive := 12;
        adcBitNb : positive := 12
    );
    PORT( 
        D            : IN     std_ulogic;
        I            : IN     std_ulogic;
        P            : IN     std_ulogic;
        SCLK         : IN     std_ulogic;
        SDO          : IN     std_ulogic;
        clock        : IN     std_ulogic;
        consigne     : IN     std_ulogic_vector (pidBitNb-1 DOWNTO 0);
        en_ADC       : IN     std_ulogic;
        en_Regulator : IN     std_ulogic;
        reset        : IN     std_ulogic;
        CS_n         : OUT    std_ulogic;
        OutADC       : OUT    std_ulogic_vector (adcBitNb-1 DOWNTO 0);
        PWM_Out      : OUT    std_ulogic
    );

-- Declarations

END motorController ;





-- VHDL Entity Modulation.pwmModulator.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 16:13:13 10/29/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY pwmModulator IS
    GENERIC( 
        signalBitNb : positive := 16
    );
    PORT( 
        clock      : IN     std_ulogic;
        parallelIn : IN     unsigned (signalBitNb-1 DOWNTO 0);
        reset      : IN     std_ulogic;
        serialOut  : OUT    std_ulogic
    );

-- Declarations

END pwmModulator ;





ARCHITECTURE RTL OF pwmModulator IS

  signal sawtooth : unsigned(parallelIn'range);

BEGIN
  ------------------------------------------------------------------------------
                                                              -- sawtooth signal
  buildSawtooth: process(clock, reset)
  begin
    if reset = '1' then
      sawtooth <= (others => '0');
    elsif rising_edge(clock) then
      sawtooth <= sawtooth + 1;
    end if;
  end process buildSawtooth;

  ------------------------------------------------------------------------------
                                                    -- compare with input signal
  buildPwm: process(sawtooth, parallelIn)
  begin
    if parallelIn > sawtooth then
      serialOut <= '1';
    else
      serialOut <= '0';
    end if;
  end process buildPwm;

END ARCHITECTURE RTL;




-- VHDL Entity Poetic.ADC.symbol
--
-- Created:
--          by - jeann.UNKNOWN (DESKTOP-V46KISN)
--          at - 09:20:19 30.06.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY ADC IS
    GENERIC( 
        adcBitNb : integer := 12
    );
    PORT( 
        SCLK   : IN     std_ulogic;
        SDO    : IN     std_ulogic;
        clock  : IN     std_ulogic;
        enable : IN     std_ulogic;
        reset  : IN     std_ulogic;
        CS_n   : OUT    std_ulogic;
        Data   : OUT    std_ulogic_vector (adcBitNb-1 DOWNTO 0)
    );

-- Declarations

END ADC ;





--
-- VHDL Architecture Poetic.ADC.ads7886_decoder
--
-- Created:
--          by - jeann.UNKNOWN (DESKTOP-V46KISN)
--          at - 14:09:37 17.06.2021
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE ads7886_decoder OF ADC IS
  type decodeState is (
    sendLowCS, waitForData, readData, sendHighCS, ready, print
  );
  signal mainState : decodeState;
  signal memSCLK, risingSCLK : std_ulogic;
  signal counterWaitData : unsigned(1 DOWNTO 0);
  signal counterReadData : unsigned(10 DOWNTO 0);
  signal dataReg : unsigned(adcBitNb-1 DOWNTO 0);
BEGIN
  decode : process(reset, clock)
  begin
    if reset = '1' then
      mainState <= ready;
      Data <= (others => '0');
      CS_n <= '1';
      counterReadData <= (others => '0');
      counterWaitData <= (others => '0');
      dataReg <= (others => '0');
    elsif rising_edge(clock) then
      case mainState is 
        when ready =>
          if enable = '1' AND risingSCLK = '1' then
            mainState <= sendLowCS;
          end if;
        when sendLowCS =>
          CS_n <= '0';
          mainState <= waitForData;
        when waitForData =>
          if risingSCLK = '1' then
            counterWaitData <= counterWaitData +1;
            if counterWaitData = 2 then
              mainState <= readData;
              counterWaitData <= (others => '0');
            end if;
          end if;
        when readData =>
          if risingSCLK = '1' then
            counterReadData <= counterReadData + 1;
            dataReg <= shift_left(dataReg, 1);
            dataReg(dataReg'low) <= SDO;
            if (counterReadData = adcBitNb-1) then
              counterReadData <= (others => '0');
              mainState <= print;
            end if;
          end if;
        when print =>
          Data <= std_ulogic_vector(dataReg);
          mainState <= sendHighCS;
        when sendHighCS =>
            if risingSCLK = '1' then
              CS_n <= '1';
              mainState <= ready;
            end if;
      end case;
    end if;
  end process decode;
  
  detectRisingSCLK : process (reset, clock)
  begin
    if reset = '1' then
      memSCLK <= '0';
      risingSCLK <= '0';
    elsif rising_edge(clock) then
      risingSCLK <= '0';
      if memSCLK = '0' AND SCLK = '1' then
        risingSCLK <= '1';
        memSCLK <= SCLK;
      else
        memSCLK <= SCLK;
      end if;
    end if;
  end process detectRisingSCLK;
  
  
END ARCHITECTURE ads7886_decoder;





-- VHDL Entity Poetic.regulator.symbol
--
-- Created:
--          by - jeann.UNKNOWN (DESKTOP-V46KISN)
--          at - 13:29:47 06.07.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY regulator IS
    GENERIC( 
        pidBitNb : positive := 12
    );
    PORT( 
        Setval        : IN     std_ulogic_vector (pidBitNb-1 DOWNTO 0);
        adc_data      : IN     std_ulogic_vector (pidBitNb-1 DOWNTO 0);
        clock         : IN     std_ulogic;
        kd_sw         : IN     std_ulogic;
        ki_sw         : IN     std_ulogic;
        kp_sw         : IN     std_ulogic;
        on_off_switch : IN     std_ulogic;
        reset         : IN     std_ulogic;
        update        : IN     std_ulogic;
        output        : OUT    unsigned (pidBitNb-1 DOWNTO 0)
    );

-- Declarations

END regulator ;





--
-- VHDL Architecture Poetic.regulator.PID2
--
-- Created:
--          by - jean.nanchen.UNKNOWN (WEA30407)
--          at - 17:33:17 22.07.2021
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE PID2 OF regulator IS
	CONSTANT con_Kp : INTEGER := 1; --proportional constant
	CONSTANT con_kp_shift_right : INTEGER := 1;
	CONSTANT con_Kd : INTEGER := 1; --differential constant
	CONSTANT con_kd_shift_right : INTEGER := 32;
	CONSTANT con_Ki : INTEGER := 1; --integral constant
	CONSTANT con_ki_shift_right : INTEGER := 32;
	SIGNAL Error, Error_difference, error_sum, old_error : unsigned(11 DOWNTO 0); --store values for controller
	SIGNAL p, i, d : unsigned(11 DOWNTO 0); --Contain the proportional, derivative and integral errors respectively
	SIGNAL output_loaded : unsigned(11 DOWNTO 0); --allows to check if output is within range
  SIGNAL output_saturation_buffer : unsigned (12 DOWNTO 0);
	SIGNAL old_adc : std_ulogic_vector(11 DOWNTO 0); --stores old adc value
  SIGNAL old_SetVal : std_ulogic_vector(11 DOWNTO 0);
  signal memUpdate, risingUpdate : std_ulogic;
  SIGNAL newError : std_ulogic;
BEGIN
  process (clock, reset)
  begin
    if reset = '1' then
      output <= (others => '0');
      Error <= (others => '0');
      Error_difference <= (others => '0');
      error_sum <= (others => '0');
      old_error <= (others => '0');
      p <= (others => '0');
      i <= (others => '0');
      d <= (others => '0');
      output_loaded <= (others => '0');
      output_saturation_buffer <= (others => '0');
      old_adc <= (others => '0');
      old_SetVal <= (others => '0');
      newError <= '0';
    elsif rising_edge(clock) then
      if risingUpdate = '1' then
        FOR k IN 0 TO 9 LOOP --for loop to run through case statement
          CASE k IS
            WHEN 0 => Error <= unsigned(SetVal) - unsigned(ADC_data); --calculates error between sensor and reference
            WHEN 1 => --IF adc_data /= old_adc THEN --calculate integral and derivative term
                      IF risingUpdate = '1' then
                        error_sum <= error_sum + error;
                        error_difference <= error - old_error;
                      END IF;
                      IF SetVal /= old_SetVal THEN
                        old_SetVal <= SetVal;
                        error_difference <= (others => '0');
                        error_sum <= (others => '0');
                      END IF;
            WHEN 2 => IF kp_sw = '1' THEN   --calculate p term if desired
                            p <= resize(shift_right(con_Kp * error, con_kp_shift_right), error'length);
                          ELSE
                            p <= (others => '0');
                          END IF;
            WHEN 3 => IF ki_sw = '1' and risingUpdate = '1' THEN --calculate i term if desired
                              i <= resize(shift_right(con_Ki * error_sum, con_ki_shift_right), error_sum'length);
                            ELSE 
                              i <= (others => '0');
                            END IF;
            WHEN 4 => IF kd_sw = '1' and risingUpdate = '1' THEN  --calculate d term if desired
                                d <= resize(shift_right(con_Kd * error_difference, con_kd_shift_right),error_difference'length);
                              ELSE 
                                d <= (others => '0');
                              END IF;
            WHEN 5 => output_saturation_buffer <= (resize(p, output_saturation_buffer'length) + i + d); --calculate output of controller
            WHEN 6 => IF output_saturation_buffer < 0 THEN --checks if output within certain range
                                output_loaded <= (others => '0');
                                ELSIF output_saturation_buffer > 4095 THEN
                                    output_loaded <= to_unsigned(4095, output_loaded'length);
                                ELSE
                                  output_loaded <= resize(output_saturation_buffer, output_loaded'length);
                                END IF;
            WHEN 7 => output <= output_loaded; --converts to std_logic_vector which can be output to DAC or input to PWM code
            WHEN 8 => old_adc <= adc_data; --storing old adc
            WHEN 9 => newError <= '0';
                      if error /= old_error  then
                        newError <= '1';
                      end if;
            WHEN OTHERS => NULL;
          END CASE;
        END LOOP;
      end if;
    end if;
  end process;
  
  
  detectRisingUpdate : process (reset, clock)
  begin
    if reset = '1' then
      memUpdate <= '0';
      risingUpdate <= '0';
    elsif rising_edge(clock) then
      risingUpdate <= '0';
      if memUpdate = '0' AND update = '1' then
        risingUpdate <= '1';
        memUpdate <= update;
      else
        memUpdate <= update;
      end if;
    end if;
  end process detectRisingUpdate;
END ARCHITECTURE PID2;





--
-- VHDL Architecture Poetic.motorController.struct
--
-- Created:
--          by - jean.nanchen.UNKNOWN (WEA30407)
--          at - 18:15:07 22.07.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

-- LIBRARY Modulation;
-- LIBRARY Poetic;

ARCHITECTURE struct OF motorController IS

    -- Architecture declarations

    -- Internal signal declarations
    SIGNAL output : unsigned(pidBitNb-1 DOWNTO 0);

    -- Implicit buffer signal declarations
    SIGNAL CS_n_internal   : std_ulogic;
    SIGNAL OutADC_internal : std_ulogic_vector (adcBitNb-1 DOWNTO 0);


    -- Component Declarations
    COMPONENT pwmModulator
    GENERIC (
        signalBitNb : positive := 16
    );
    PORT (
        clock      : IN     std_ulogic ;
        parallelIn : IN     unsigned (signalBitNb-1 DOWNTO 0);
        reset      : IN     std_ulogic ;
        serialOut  : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT ADC
    GENERIC (
        adcBitNb : integer := 12
    );
    PORT (
        SCLK   : IN     std_ulogic ;
        SDO    : IN     std_ulogic ;
        clock  : IN     std_ulogic ;
        enable : IN     std_ulogic ;
        reset  : IN     std_ulogic ;
        CS_n   : OUT    std_ulogic ;
        Data   : OUT    std_ulogic_vector (adcBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT regulator
    GENERIC (
        pidBitNb : positive := 12
    );
    PORT (
        Setval        : IN     std_ulogic_vector (pidBitNb-1 DOWNTO 0);
        adc_data      : IN     std_ulogic_vector (pidBitNb-1 DOWNTO 0);
        clock         : IN     std_ulogic ;
        kd_sw         : IN     std_ulogic ;
        ki_sw         : IN     std_ulogic ;
        kp_sw         : IN     std_ulogic ;
        on_off_switch : IN     std_ulogic ;
        reset         : IN     std_ulogic ;
        update        : IN     std_ulogic ;
        output        : OUT    unsigned (pidBitNb-1 DOWNTO 0)
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : ADC USE ENTITY Poetic.ADC;
--     FOR ALL : pwmModulator USE ENTITY Modulation.pwmModulator;
--     FOR ALL : regulator USE ENTITY Poetic.regulator;
    -- pragma synthesis_on


BEGIN

    -- Instance port mappings.
    I43 : pwmModulator
        GENERIC MAP (
            signalBitNb => 12
        )
        PORT MAP (
            clock      => clock,
            parallelIn => output,
            reset      => reset,
            serialOut  => PWM_Out
        );
    U_0 : ADC
        GENERIC MAP (
            adcBitNb => 12
        )
        PORT MAP (
            SCLK   => SCLK,
            SDO    => SDO,
            clock  => clock,
            enable => en_ADC,
            reset  => reset,
            CS_n   => CS_n_internal,
            Data   => OutADC_internal
        );
    U_1 : regulator
        GENERIC MAP (
            pidBitNb => 12
        )
        PORT MAP (
            Setval        => consigne,
            adc_data      => OutADC_internal,
            clock         => clock,
            kd_sw         => D,
            ki_sw         => I,
            kp_sw         => P,
            on_off_switch => en_Regulator,
            reset         => reset,
            update        => CS_n_internal,
            output        => output
        );

    -- Implicit buffered output assignments
    CS_n   <= CS_n_internal;
    OutADC <= OutADC_internal;

END struct;




-- VHDL Entity Board.DFF.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:07:05 02/19/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY DFF IS
    PORT( 
        CLK : IN     std_uLogic;
        CLR : IN     std_uLogic;
        D   : IN     std_uLogic;
        Q   : OUT    std_uLogic
    );

-- Declarations

END DFF ;





ARCHITECTURE sim OF DFF IS
BEGIN

  process(clk, clr)
  begin
    if clr = '1' then
      q <= '0';
    elsif rising_edge(clk) then
      q <= d;
    end if;
  end process;

END ARCHITECTURE sim;





-- VHDL Entity Poetic.clockGenerator.symbol
--
-- Created:
--          by - jeann.UNKNOWN (DESKTOP-V46KISN)
--          at - 11:37:15 17.06.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY clockGenerator IS
    GENERIC( 
        counterBitNb : integer := 12;
        countValue   : integer := 250
    );
    PORT( 
        clock    : IN     std_ulogic;
        enable   : IN     std_ulogic;
        reset    : IN     std_ulogic;
        clockOut : OUT    std_ulogic
    );

-- Declarations

END clockGenerator ;





--
-- VHDL Architecture Poetic.clockGenerator.clockDivider
--
-- Created:
--          by - jeann.UNKNOWN (DESKTOP-V46KISN)
--          at - 11:15:13 17.06.2021
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE clockDivider OF clockGenerator IS
  signal counter : unsigned(counterBitNb-1 DOWNTO 0);
  signal clockOut_int : std_ulogic;
BEGIN
  clockOut <= clockOut_int;
  increment : process(reset, clock)
  begin
    if reset = '1' then
	  clockOut_int <= '0';
      counter <= (others => '0');
      counter(counter'low) <= '1';
    elsif rising_edge(clock) then
      if enable = '1' then
        counter <= counter + 1;
          if (counter >= countValue) then
            clockOut_int <= not clockOut_int;
            counter <= (others => '0');
            counter(counter'low) <= '1';
          end if;
      else
        clockOut_int <= '0';
      end if;
    end if;
  end process increment;
END ARCHITECTURE clockDivider;





-- VHDL Entity Poetic.DAC.symbol
--
-- Created:
--          by - jeann.UNKNOWN (DESKTOP-V46KISN)
--          at - 11:29:40 14.07.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY DAC IS
    GENERIC( 
        dacBitNb   : positive := 8;
        dacChBitNb : positive := 2;
        dacOpBitNb : positive := 2
    );
    PORT( 
        SCLK   : IN     std_ulogic;
        clock  : IN     std_ulogic;
        dacSel : IN     std_ulogic_vector (dacChBitNb-1 DOWNTO 0);
        data   : IN     std_ulogic_vector (dacBitNb-1 DOWNTO 0);
        mode   : IN     std_ulogic_vector (dacOpBitNb-1 DOWNTO 0);
        reset  : IN     std_ulogic;
        send   : IN     std_ulogic;
        Dout   : OUT    std_ulogic;
        Sync_n : OUT    std_ulogic
    );

-- Declarations

END DAC ;





--
-- VHDL Architecture Poetic.DAC.DAC124S085
--
-- Created:
--          by - jeann.UNKNOWN (DESKTOP-V46KISN)
--          at - 09:21:02 18.06.2021
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE DAC124S085 OF DAC IS
  signal memSCLK, risingSCLK : std_ulogic;
  signal masterWr : std_ulogic;
  signal masterData : std_ulogic_vector(dacBitNb+dacChBitNb+dacOpBitNb-1 DOWNTO 0);
  type transmitState is(
    waitForATransmission, sendData, sendLowSync, sendHighSync, sendFourZero
  );
  signal mainState : transmitState;
BEGIN
  concatenate : process (reset, clock)
  begin
    if reset = '1' then
      masterData <= (others => '0');
      masterWr <= '0';
    elsif rising_edge(clock) then
    masterWr <= '0';
      if send = '1' then
        masterData <= dacSel & mode & data;
        masterWr <= '1';
      end if;
    end if;
  end process concatenate;
  
  transmit : process (reset, clock)
  variable decounter : integer;
  variable counter : integer;
  begin
    if reset = '1' then
      mainState <= waitForATransmission;
      decounter := masterData'length-1;
      Sync_n <= '1';
      Dout <= '0';
	  counter := 0;
    elsif rising_edge(clock) then
      case mainState is
        when waitForATransmission =>
          if masterWr = '1' then
            mainState <= sendLowSync;
          end if;
        when sendData =>
          if risingSCLK = '1' then
            decounter := decounter - 1;
            Dout <= masterData(decounter);
            if decounter = 0 then
              mainState <= sendFourZero;
            end if;
          end if;
        when sendLowSync =>
          if risingSCLK = '1' then
            Sync_n <= '0';
            Dout <= masterData(decounter);
            mainState <= sendData;
          end if;
        when sendHighSync =>
          decounter := masterData'length-1;
		  counter := 0;
          if risingSCLK = '1' then
            Sync_n <= '1';
            mainState <= waitForATransmission;
          end if;
		when sendFourZero =>
		  if risingSCLK = '1' then
		    Dout <= '0';
			counter := counter + 1;
			if counter = 4 then
			  mainState <= sendHighSync;
			end if;
		  end if;
      end case;
    end if;
  end process transmit;
  
  detectRisingSCLK : process (reset, clock)
  begin
    if reset = '1' then
      memSCLK <= '0';
      risingSCLK <= '0';
    elsif rising_edge(clock) then
      risingSCLK <= '0';
      if memSCLK = '0' AND SCLK = '1' then
        risingSCLK <= '1';
        memSCLK <= SCLK;
      else
        memSCLK <= SCLK;
      end if;
    end if;
  end process detectRisingSCLK;
END ARCHITECTURE DAC124S085;





LIBRARY ieee;
USE ieee.std_logic_1164.all;

PACKAGE gates IS

--  constant gateDelay: time := 1 ns;
  constant gateDelay: time := 0.1 ns;

END gates;




-- VHDL Entity Gates.and2inv1.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:34:52 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY and2inv1 IS
    GENERIC( 
        delay : time := gateDelay
    );
    PORT( 
        in1  : IN     std_uLogic;
        in2  : IN     std_uLogic;
        out1 : OUT    std_uLogic
    );

-- Declarations

END and2inv1 ;





ARCHITECTURE sim OF and2inv1 IS
BEGIN
  out1 <= in1 and (not in2) after delay;
END ARCHITECTURE sim;




-- VHDL Entity Gates.logic0.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:35:14 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY logic0 IS
    PORT( 
        logic_0 : OUT    std_uLogic
    );

-- Declarations

END logic0 ;





ARCHITECTURE sim OF logic0 IS
BEGIN
  logic_0 <= '0';
END sim;




-- VHDL Entity Gates.logic1.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:35:13 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY logic1 IS
    PORT( 
        logic_1 : OUT    std_uLogic
    );

-- Declarations

END logic1 ;





ARCHITECTURE sim OF logic1 IS
BEGIN
  logic_1 <= '1';
END sim;




--
-- VHDL Architecture Poetic.SimplePoeticDcMotor.struct
--
-- Created:
--          by - jean.nanchen.UNKNOWN (WEA30407)
--          at - 16:16:43 22.07.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
use work.gates.all;

-- LIBRARY Board;
-- LIBRARY Poetic;
-- LIBRARY RS232;

ARCHITECTURE struct OF SimplePoeticDcMotor IS

    -- Architecture declarations

    -- Internal signal declarations
    SIGNAL OutADC       : std_ulogic_vector(adcBitNb-1 DOWNTO 0);
    SIGNAL Q            : std_uLogic;
    SIGNAL consigne     : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
    SIGNAL dacSel       : std_ulogic_vector(dacChBitNb-1 DOWNTO 0);
    SIGNAL endOfMsg     : std_ulogic;
    SIGNAL mode         : std_ulogic_vector(dacOpBitNb-1 DOWNTO 0);
    SIGNAL newCharacter : std_ulogic;
    SIGNAL out1         : std_uLogic;
    SIGNAL output       : std_ulogic_vector(11 DOWNTO 0);
    SIGNAL rxData       : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
    SIGNAL rxEmpty      : std_ulogic;
    SIGNAL rxRd         : std_ulogic;
    SIGNAL sendDataDac  : std_uLogic;
    SIGNAL txFull       : std_ulogic;

    -- Implicit buffer signal declarations
    SIGNAL ADC_SCLK_internal : std_ulogic;
    SIGNAL BP_PWMA_internal  : std_ulogic;
    SIGNAL DAC_SCLK_internal : std_ulogic;


    -- Component Declarations
    COMPONENT DFF
    PORT (
        CLK : IN     std_uLogic ;
        CLR : IN     std_uLogic ;
        D   : IN     std_uLogic ;
        Q   : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT and2inv1
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        in1  : IN     std_uLogic ;
        in2  : IN     std_uLogic ;
        out1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT logic0
    PORT (
        logic_0 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT logic1
    PORT (
        logic_1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT DAC
    GENERIC (
        dacBitNb   : positive := 8;
        dacChBitNb : positive := 2;
        dacOpBitNb : positive := 2
    );
    PORT (
        SCLK   : IN     std_ulogic ;
        clock  : IN     std_ulogic ;
        dacSel : IN     std_ulogic_vector (dacChBitNb-1 DOWNTO 0);
        data   : IN     std_ulogic_vector (dacBitNb-1 DOWNTO 0);
        mode   : IN     std_ulogic_vector (dacOpBitNb-1 DOWNTO 0);
        reset  : IN     std_ulogic ;
        send   : IN     std_ulogic ;
        Dout   : OUT    std_ulogic ;
        Sync_n : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT clockGenerator
    GENERIC (
        counterBitNb : integer := 12;
        countValue   : integer := 250
    );
    PORT (
        clock    : IN     std_ulogic ;
        enable   : IN     std_ulogic ;
        reset    : IN     std_ulogic ;
        clockOut : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT motorController
    GENERIC (
        pidBitNb : positive := 12;
        adcBitNb : positive := 12
    );
    PORT (
        D            : IN     std_ulogic ;
        I            : IN     std_ulogic ;
        P            : IN     std_ulogic ;
        SCLK         : IN     std_ulogic ;
        SDO          : IN     std_ulogic ;
        clock        : IN     std_ulogic ;
        consigne     : IN     std_ulogic_vector (pidBitNb-1 DOWNTO 0);
        en_ADC       : IN     std_ulogic ;
        en_Regulator : IN     std_ulogic ;
        reset        : IN     std_ulogic ;
        CS_n         : OUT    std_ulogic ;
        OutADC       : OUT    std_ulogic_vector (adcBitNb-1 DOWNTO 0);
        PWM_Out      : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT serialAsciiDecoder
    PORT (
        clock        : IN     std_ulogic ;
        consigne     : IN     std_ulogic_vector (7 DOWNTO 0);
        endOfMsg     : IN     std_ulogic ;
        newCharacter : IN     std_ulogic ;
        reset        : IN     std_ulogic ;
        output       : OUT    std_ulogic_vector (11 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT uartController
    GENERIC (
        dataBitNb : positive := 8
    );
    PORT (
        clock        : IN     std_ulogic ;
        reset        : IN     std_ulogic ;
        rxData       : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        rxEmpty      : IN     std_ulogic ;
        txFull       : IN     std_ulogic ;
        consigne     : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        endOfMsg     : OUT    std_ulogic ;
        newCharacter : OUT    std_ulogic ;
        rxRd         : OUT    std_ulogic ;
        txData       : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        txWr         : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT serialPortFIFO
    GENERIC (
        baudRateDivide : positive := 2083;
        dataBitNb      : positive := 8;
        txFifoDepth    : positive := 8;
        rxFifoDepth    : positive := 8
    );
    PORT (
        RxD     : IN     std_ulogic ;
        TxD     : OUT    std_ulogic ;
        clock   : IN     std_ulogic ;
        reset   : IN     std_ulogic ;
        rxEmpty : OUT    std_ulogic ;
        rxRd    : IN     std_ulogic ;
        rxData  : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        txData  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        txFull  : OUT    std_ulogic ;
        txWr    : IN     std_ulogic 
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : DAC USE ENTITY Poetic.DAC;
--     FOR ALL : DFF USE ENTITY Board.DFF;
--     FOR ALL : and2inv1 USE ENTITY Gates.and2inv1;
--     FOR ALL : clockGenerator USE ENTITY Poetic.clockGenerator;
--     FOR ALL : logic0 USE ENTITY Gates.logic0;
--     FOR ALL : logic1 USE ENTITY Gates.logic1;
--     FOR ALL : motorController USE ENTITY Poetic.motorController;
--     FOR ALL : serialAsciiDecoder USE ENTITY Poetic.serialAsciiDecoder;
--     FOR ALL : serialPortFIFO USE ENTITY RS232.serialPortFIFO;
--     FOR ALL : uartController USE ENTITY Poetic.uartController;
    -- pragma synthesis_on


BEGIN

    -- Instance port mappings.
    I_dff1 : DFF
        PORT MAP (
            CLK => clock,
            CLR => reset,
            D   => BP_PWMA_internal,
            Q   => BP_PWMB
        );
    I_dff2 : DFF
        PORT MAP (
            CLK => clock,
            CLR => reset,
            D   => ADC_SCLK_internal,
            Q   => Q
        );
    U_2 : and2inv1
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => ADC_SCLK_internal,
            in2  => txFull,
            out1 => out1
        );
    U_8 : and2inv1
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => ADC_SCLK_internal,
            in2  => Q,
            out1 => sendDataDac
        );
    U_4 : logic0
        PORT MAP (
            logic_0 => mode(0)
        );
    U_6 : logic0
        PORT MAP (
            logic_0 => dacSel(0)
        );
    U_7 : logic0
        PORT MAP (
            logic_0 => dacSel(1)
        );
    U_5 : logic1
        PORT MAP (
            logic_1 => mode(1)
        );
    U_1 : DAC
        GENERIC MAP (
            dacBitNb   => 8,
            dacChBitNb => 2,
            dacOpBitNb => 2
        )
        PORT MAP (
            SCLK   => DAC_SCLK_internal,
            clock  => clock,
            dacSel => dacSel,
            data   => OutADC(adcBitNb-1 DOWNTO 4),
            mode   => mode,
            reset  => reset,
            send   => sendDataDac,
            Dout   => DAC_SDO,
            Sync_n => DAC_SYNC
        );
    U_0 : clockGenerator
        GENERIC MAP (
            counterBitNb => 25,
            countValue   => 6
        )
        PORT MAP (
            clock    => clock,
            enable   => enable,
            reset    => reset,
            clockOut => ADC_SCLK_internal
        );
    U_3 : clockGenerator
        GENERIC MAP (
            counterBitNb => 10,
            countValue   => 3
        )
        PORT MAP (
            clock    => clock,
            enable   => enable,
            reset    => reset,
            clockOut => DAC_SCLK_internal
        );
    I6 : motorController
        GENERIC MAP (
            pidBitNb => 12,
            adcBitNb => 12
        )
        PORT MAP (
            D            => D,
            I            => I,
            P            => P,
            SCLK         => ADC_SCLK_internal,
            SDO          => ADC_SDO,
            clock        => clock,
            consigne     => output,
            en_ADC       => enable,
            en_Regulator => enable,
            reset        => reset,
            CS_n         => ADC_CS,
            OutADC       => OutADC,
            PWM_Out      => BP_PWMA_internal
        );
    I23 : serialAsciiDecoder
        PORT MAP (
            clock        => clock,
            consigne     => consigne,
            endOfMsg     => endOfMsg,
            newCharacter => newCharacter,
            reset        => reset,
            output       => output
        );
    I22 : uartController
        GENERIC MAP (
            dataBitNb => 8
        )
        PORT MAP (
            clock        => clock,
            reset        => reset,
            rxData       => rxData,
            rxEmpty      => rxEmpty,
            txFull       => txFull,
            consigne     => consigne,
            endOfMsg     => endOfMsg,
            newCharacter => newCharacter,
            rxRd         => rxRd,
            txData       => OPEN,
            txWr         => OPEN
        );
    I0 : serialPortFIFO
        GENERIC MAP (
            baudRateDivide => 10417,
            dataBitNb      => 8,
            txFifoDepth    => 8,
            rxFifoDepth    => 1
        )
        PORT MAP (
            RxD     => USB_TX,
            TxD     => USB_RX,
            clock   => clock,
            reset   => reset,
            rxEmpty => rxEmpty,
            rxRd    => rxRd,
            rxData  => rxData,
            txData  => output(11 DOWNTO 4),
            txFull  => txFull,
            txWr    => out1
        );

    -- Implicit buffered output assignments
    ADC_SCLK <= ADC_SCLK_internal;
    BP_PWMA  <= BP_PWMA_internal;
    DAC_SCLK <= DAC_SCLK_internal;

END struct;




-- VHDL Entity Board.inverterIn.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:07:14 02/19/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY inverterIn IS
    PORT( 
        in1  : IN     std_uLogic;
        out1 : OUT    std_uLogic
    );

-- Declarations

END inverterIn ;





ARCHITECTURE sim OF inverterIn IS
BEGIN

  out1 <= NOT in1;

END ARCHITECTURE sim;





--
-- VHDL Architecture Board.poetic_circuit.studentVersion
--
-- Created:
--          by - jean.nanchen.UNKNOWN (WEA30407)
--          at - 16:53:31 22.07.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
use work.gates.all;

-- LIBRARY Board;
-- LIBRARY Poetic;

ARCHITECTURE studentVersion OF poetic_circuit IS

    -- Architecture declarations
    constant signalBitNb: positive := 16;
    constant phaseBitNb: positive := 17;
    constant stepX: positive := 2;
    constant stepY: positive := 3;

    -- Internal signal declarations
    SIGNAL logic1      : std_uLogic;
    SIGNAL logic_0     : std_uLogic;
    SIGNAL reset       : std_ulogic;
    SIGNAL resetSnch_N : std_ulogic;
    SIGNAL resetSynch  : std_ulogic;


    -- Component Declarations
    COMPONENT DFF
    PORT (
        CLK : IN     std_uLogic ;
        CLR : IN     std_uLogic ;
        D   : IN     std_uLogic ;
        Q   : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT inverterIn
    PORT (
        in1  : IN     std_uLogic ;
        out1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT logic0
    PORT (
        logic_0 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT SimplePoeticDcMotor
    GENERIC (
        dataBitNb  : positive := 8;
        pidBitNb   : positive := 12;
        adcBitNb   : positive := 12;
        dacBitNb   : positive := 8;
        dacChBitNb : positive := 2;
        dacOpBitNb : positive := 2
    );
    PORT (
        ADC_SDO  : IN     std_ulogic ;
        D        : IN     std_ulogic ;
        I        : IN     std_ulogic ;
        P        : IN     std_ulogic ;
        USB_TX   : IN     std_ulogic ;
        clock    : IN     std_ulogic ;
        enable   : IN     std_ulogic ;
        reset    : IN     std_ulogic ;
        ADC_CS   : OUT    std_ulogic ;
        ADC_SCLK : OUT    std_ulogic ;
        BP_PWMA  : OUT    std_ulogic ;
        BP_PWMB  : OUT    std_ulogic ;
        DAC_SCLK : OUT    std_ulogic ;
        DAC_SDO  : OUT    std_ulogic ;
        DAC_SYNC : OUT    std_ulogic ;
        USB_RX   : OUT    std_ulogic 
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : DFF USE ENTITY Board.DFF;
--     FOR ALL : SimplePoeticDcMotor USE ENTITY Poetic.SimplePoeticDcMotor;
--     FOR ALL : inverterIn USE ENTITY Board.inverterIn;
--     FOR ALL : logic0 USE ENTITY Gates.logic0;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 4 eb4
    logic1 <= '1';


    -- Instance port mappings.
    I_dff : DFF
        PORT MAP (
            CLK => clock,
            CLR => reset,
            D   => logic1,
            Q   => resetSnch_N
        );
    I_dff1 : DFF
        PORT MAP (
            CLK => clock,
            CLR => resetSynch,
            D   => D,
            Q   => Q
        );
    I_dff2 : DFF
        PORT MAP (
            CLK => clock,
            CLR => resetSynch,
            D   => logic1,
            Q   => Q1
        );
    I_inv1 : inverterIn
        PORT MAP (
            in1  => reset_N,
            out1 => reset
        );
    I_inv2 : inverterIn
        PORT MAP (
            in1  => resetSnch_N,
            out1 => resetSynch
        );
    I1 : logic0
        PORT MAP (
            logic_0 => logic_0
        );
    I0 : SimplePoeticDcMotor
        GENERIC MAP (
            dataBitNb  => 8,
            pidBitNb   => 12,
            adcBitNb   => 12,
            dacBitNb   => 8,
            dacChBitNb => 2,
            dacOpBitNb => 2
        )
        PORT MAP (
            ADC_SDO  => ADC_SDO,
            D        => logic_0,
            I        => logic1,
            P        => logic1,
            USB_TX   => USB_TX,
            clock    => clock,
            enable   => logic1,
            reset    => resetSynch,
            ADC_CS   => ADC_CS,
            ADC_SCLK => ADC_SCLK,
            BP_PWMA  => BP_PWMA,
            BP_PWMB  => BP_PWMB,
            DAC_SCLK => DAC_SCLK,
            DAC_SDO  => DAC_SDO,
            DAC_SYNC => DAC_SYNC,
            USB_RX   => USB_RX
        );

END studentVersion;




