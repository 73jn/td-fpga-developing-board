--
-- VHDL Architecture Poetic.uartController.fsm
--
-- Created:
--          by - jeann.UNKNOWN (DESKTOP-V46KISN)
--          at - 11:24:47 30.06.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
 
ARCHITECTURE fsm OF uartController IS

    TYPE STATE_TYPE IS (
        waitForCommand,
        dispatcher,
        S_select,
        S_receive,
        S_waitForOtherCharacter
    );
 
    -- Declare current and next state signals
    SIGNAL current_state : STATE_TYPE;
    SIGNAL next_state : STATE_TYPE;

BEGIN

    -----------------------------------------------------------------
    clocked_proc : PROCESS ( 
        clock,
        reset
    )
    -----------------------------------------------------------------
    BEGIN
        IF (reset = '1') THEN
            current_state <= waitForCommand;
        ELSIF (clock'EVENT AND clock = '1') THEN
            current_state <= next_state;
        END IF;
    END PROCESS clocked_proc;
 
    -----------------------------------------------------------------
    nextstate_proc : PROCESS ( 
        current_state,
        rxData,
        rxEmpty
    )
    -----------------------------------------------------------------
    BEGIN
        CASE current_state IS
            WHEN waitForCommand => 
                IF (rxEmpty = '0') THEN 
                    next_state <= dispatcher;
                ELSE
                    next_state <= waitForCommand;
                END IF;
            WHEN dispatcher => 
                IF (rxData = X"53") THEN 
                    next_state <= S_select;
                ELSE
                    next_state <= waitForCommand;
                END IF;
            WHEN S_select => 
                IF (rxEmpty = '0') THEN 
                    next_state <= S_receive;
                ELSE
                    next_state <= S_select;
                END IF;
            WHEN S_receive => 
                IF (rxData /= X"65") THEN 
                    next_state <= S_waitForOtherCharacter;
                ELSIF (rxData = X"65") THEN 
                    next_state <= waitForCommand;
                ELSE
                    next_state <= S_receive;
                END IF;
            WHEN S_waitForOtherCharacter => 
                IF (rxEmpty = '0') THEN 
                    next_state <= S_receive;
                ELSE
                    next_state <= S_waitForOtherCharacter;
                END IF;
            WHEN OTHERS =>
                next_state <= waitForCommand;
        END CASE;
    END PROCESS nextstate_proc;
 
    -----------------------------------------------------------------
    output_proc : PROCESS ( 
        current_state,
        rxData
    )
    -----------------------------------------------------------------
    BEGIN

        -- Combined Actions
        CASE current_state IS
            WHEN waitForCommand => 
                newCharacter <= '0';
                rxRd <= '0';
                consigne <= (others => '0');
                endOfMsg <= '0';
            WHEN dispatcher => 
                IF (NOT(rxData = X"53")) THEN 
                    rxRd <= '1';
                END IF;
            WHEN S_select => 
                rxRd <= '1';
                newCharacter <= '0';
            WHEN S_receive => 
                consigne <= rxData;
                if rxData /= X"65" then
                  newCharacter <= '1';
                end if;
                rxRd <= '1';
                IF (rxData /= X"65") THEN 
                ELSIF (rxData = X"65") THEN 
                    endOfMsg <= '1';
                END IF;
            WHEN S_waitForOtherCharacter => 
                rxRd <= '0';
                newCharacter <= '0';
            WHEN OTHERS =>
                NULL;
        END CASE;
    END PROCESS output_proc;
 
END fsm;
